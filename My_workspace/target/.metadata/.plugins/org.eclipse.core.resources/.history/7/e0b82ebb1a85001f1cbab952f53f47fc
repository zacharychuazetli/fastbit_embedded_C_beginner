/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *a/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

int main(void)
{
	uint32_t *pClkCtrlReg = (uint32_t*)0x40023830;
	uint32_t *pPortDModeReg = (uint32_t*)0x40020C00;
	uint32_t *pPortDOutReg = (uint32_t*)0x40020C14;

	uint32_t *pPortAModeReg = (uint32_t*)0x40020000;

	//1. enable the clock for GPIOD, and GPIOA peripheral in the AHB1ENR (same for both, same bus)
	//GPIO D
	*pClkCtrlReg |= (1 << 3);
	//GPIO A
	*pClkCtrlReg |= (1 << 0);

	//2. configure the mode of the IO pin PD12 as output
	//a. clear the 24th and 25th bit positions (clear)
	*pPortDModeReg &= ~(3 << 24);
	//b. make 24th bit position as 1 (set)
	*pPortDModeReg |= (1 << 24);

	//2. configure the mode of the IO pin PA0 as input (GPIOA Mode Register)
	*pPortAModeReg &= ~(3 << 24);
	//b. make 24th bit position as 1 (set)
	*pPortAModeReg |= (1 << 24);

	while(1)
	{
		//3. set 12th bit of the output data register to make I/O pin-12 high
		*pPortDOutReg |= (1 << 12);

		// introduce small human observable delay
		// This loop executes for 300k times
		// set i < 10 when using debugger, because debugger much slower
		/* The main reason stepping over delays takes longer in debugging is due to
		   the overhead introduced by the debugger itself. The debugger monitors execution,
		   checks breakpoints, and updates debugging information, which slows down the code's
		   execution compared to running it without debugging.
		 */
		for(uint32_t i=0; i < 300000 ; i++);

		// Turn Off the LEd
		*pPortDOutReg &= ~(1 << 12);

		for(uint32_t i=0; i < 300000 ; i++);
	}

}
